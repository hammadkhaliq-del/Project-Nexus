"""
Logic Engine - Rule-Based Reasoning System
Implements IF-THEN rules for anomaly detection and alert generation
"""
from typing import List, Dict, Any, Callable
from dataclasses import dataclass
from enum import Enum

from core.agent import Vehicle, VehicleStatus
from core.city import City, Weather
from utils.logger import setup_logger

logger = setup_logger(__name__)


class AlertLevel(Enum):
    """Alert severity levels"""
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


@dataclass
class Rule:
    """Represents a logic rule"""
    id: str
    name: str
    condition: Callable[[Dict[str, Any]], bool]
    action: Callable[[Dict[str, Any]], str]
    alert_level: AlertLevel
    enabled: bool = True


@dataclass
class Alert:
    """Alert generated by rule firing"""
    rule_id: str
    rule_name: str
    message: str
    alert_level: AlertLevel
    tick: int
    context: Dict[str, Any]


class LogicEngine:
    """
    AI Engine #3: Rule-Based Logic System
    Monitors city state and triggers alerts when rules fire
    
    Example Rules:
    - IF speed drops AND road is clear → Engine Failure
    - IF energy < 25% → Recharge Alert
    - IF smoke detected → Fire Risk Alert
    - IF vehicle stuck for 5+ ticks → Traffic Jam Alert
    """
    
    def __init__(self, city: City):
        self.city = city
        self.rules: List[Rule] = []
        self.alerts: List[Alert] = []
        self.rule_fire_counts: Dict[str, int] = {}
        
        # Initialize rules
        self._initialize_rules()
        
        logger.info(f"Logic Engine initialized with {len(self.rules)} rules")
    
    def _initialize_rules(self):
        """Initialize all logic rules"""
        
        # Rule 1: Low Energy Alert
        self.rules.append(Rule(
            id="R01",
            name="Low Energy Alert",
            condition=lambda ctx: ctx.get("energy", 100) < 25,
            action=lambda ctx: (
                f"Vehicle {ctx['vehicle_id']} has critically low energy ({ctx['energy']:.1f}%). "
                f"Recommend immediate recharging to avoid stranding."
            ),
            alert_level=AlertLevel.WARNING
        ))
        
        # Rule 2: Engine Failure Detection
        self.rules.append(Rule(
            id="R02",
            name="Engine Failure Detection",
            condition=lambda ctx: (
                ctx.get("speed", 50) < 20 and
                ctx.get("health", 100) < 50 and
                ctx.get("status") == "moving"
            ),
            action=lambda ctx: (
                f"Possible engine failure detected for vehicle {ctx['vehicle_id']}. "
                f"Speed dropped to {ctx['speed']:.1f} with health at {ctx['health']:.1f}%. "
                f"Maintenance required."
            ),
            alert_level=AlertLevel.CRITICAL
        ))
        
        # Rule 3: Severe Weather Warning
        self.rules.append(Rule(
            id="R03",
            name="Severe Weather Alert",
            condition=lambda ctx: ctx.get("weather") in ["rain", "snow"],
            action=lambda ctx: (
                f"Severe weather conditions detected: {ctx['weather'].upper()}. "
                f"Accident probability increased by {ctx['weather_modifier']:.1f}x. "
                f"All vehicles advised to reduce speed."
            ),
            alert_level=AlertLevel.WARNING
        ))
        
        # Rule 4: Traffic Jam Detection
        self.rules.append(Rule(
            id="R04",
            name="Traffic Jam Detection",
            condition=lambda ctx: ctx.get("stuck_counter", 0) > 5,
            action=lambda ctx: (
                f"Traffic jam detected at position {ctx['position']}. "
                f"Vehicle {ctx['vehicle_id']} stuck for {ctx['stuck_counter']} ticks. "
                f"Alternative routes should be considered."
            ),
            alert_level=AlertLevel.WARNING
        ))
        
        # Rule 5: Power Shortage Alert
        self.rules.append(Rule(
            id="R05",
            name="Power Shortage Alert",
            condition=lambda ctx: ctx.get("power_utilization", 0) > 95,
            action=lambda ctx: (
                f"Critical power shortage: {ctx['power_utilization']:.1f}% capacity used. "
                f"{ctx['unsatisfied_buildings']} buildings may experience power cuts. "
                f"Load shedding may be necessary."
            ),
            alert_level=AlertLevel.CRITICAL
        ))
        
        # Rule 6: Emergency Response Delay
        self.rules.append(Rule(
            id="R06",
            name="Emergency Response Delay",
            condition=lambda ctx: (
                ctx.get("emergency_age", 0) > 50 and
                not ctx.get("assigned", False)
            ),
            action=lambda ctx: (
                f"Emergency {ctx['emergency_id']} at {ctx['position']} unassigned for "
                f"{ctx['emergency_age']} ticks (severity: {ctx['severity']}). "
                f"No available emergency vehicles."
            ),
            alert_level=AlertLevel.CRITICAL
        ))
        
        # Rule 7: Multiple Simultaneous Emergencies
        self.rules.append(Rule(
            id="R07",
            name="Multiple Emergency Alert",
            condition=lambda ctx: ctx.get("active_emergencies", 0) >= 3,
            action=lambda ctx: (
                f"Multiple emergencies active: {ctx['active_emergencies']} incidents requiring attention. "
                f"Emergency services at capacity. Consider requesting additional resources."
            ),
            alert_level=AlertLevel.CRITICAL
        ))
        
        # Rule 8: Vehicle Health Degradation
        self.rules.append(Rule(
            id="R08",
            name="Vehicle Health Alert",
            condition=lambda ctx: ctx.get("health", 100) < 30,
            action=lambda ctx: (
                f"Vehicle {ctx['vehicle_id']} health critically low ({ctx['health']:.1f}%). "
                f"Risk of breakdown. Immediate maintenance recommended."
            ),
            alert_level=AlertLevel.WARNING
        ))
        
        # Rule 9: Fire Risk in High Density Area
        self.rules.append(Rule(
            id="R09",
            name="Fire Risk Alert",
            condition=lambda ctx: (
                ctx.get("event_type") == "fire" and
                ctx.get("nearby_buildings", 0) > 3
            ),
            action=lambda ctx: (
                f"Fire detected near high-density area with {ctx['nearby_buildings']} nearby buildings. "
                f"High risk of spread. Priority response required."
            ),
            alert_level=AlertLevel.CRITICAL
        ))
        
        # Rule 10: Road Block Impact
        self.rules.append(Rule(
            id="R10",
            name="Road Block Impact Alert",
            condition=lambda ctx: (
                ctx.get("blocked_roads", 0) > 0 and
                ctx.get("affected_vehicles", 0) > 2
            ),
            action=lambda ctx: (
                f"{ctx['blocked_roads']} roads blocked affecting {ctx['affected_vehicles']} vehicles. "
                f"Traffic rerouting in progress. Expect delays."
            ),
            alert_level=AlertLevel.INFO
        ))
    
    def evaluate(self, tick: int, vehicles: List[Vehicle]) -> List[Alert]:
        """
        Evaluate all rules against current state
        Returns list of triggered alerts
        """
        new_alerts = []
        
        # Evaluate vehicle-specific rules
        for vehicle in vehicles:
            context = self._build_vehicle_context(vehicle, tick)
            alerts = self._evaluate_rules(context, tick)
            new_alerts.extend(alerts)
        
        # Evaluate city-wide rules
        city_context = self._build_city_context(tick, vehicles)
        city_alerts = self._evaluate_rules(city_context, tick)
        new_alerts.extend(city_alerts)
        
        # Store alerts
        self.alerts.extend(new_alerts)
        
        # Limit alert history
        if len(self.alerts) > 500:
            self.alerts = self.alerts[-500:]
        
        return new_alerts
    
    def _evaluate_rules(self, context: Dict[str, Any], tick: int) -> List[Alert]:
        """Evaluate all rules against given context"""
        alerts = []
        
        for rule in self.rules:
            if not rule.enabled:
                continue
            
            try:
                if rule.condition(context):
                    message = rule.action(context)
                    
                    alert = Alert(
                        rule_id=rule.id,
                        rule_name=rule.name,
                        message=message,
                        alert_level=rule.alert_level,
                        tick=tick,
                        context=context.copy()
                    )
                    
                    alerts.append(alert)
                    
                    # Update fire counts
                    self.rule_fire_counts[rule.id] = self.rule_fire_counts.get(rule.id, 0) + 1
                    
                    logger.info(f"Rule {rule.id} ({rule.name}) fired: {message}")
            
            except Exception as e:
                logger.error(f"Error evaluating rule {rule.id}: {e}")
        
        return alerts
    
    def _build_vehicle_context(self, vehicle: Vehicle, tick: int) -> Dict[str, Any]:
        """Build context dictionary for vehicle"""
        return {
            "vehicle_id": vehicle.id,
            "position": vehicle.position,
            "speed": vehicle.speed,
            "health": vehicle.health,
            "energy": vehicle.energy,
            "status": vehicle.status.value,
            "stuck_counter": vehicle.stuck_counter,
            "is_emergency": vehicle.is_emergency,
            "tick": tick
        }
    
    def _build_city_context(self, tick: int, vehicles: List[Vehicle]) -> Dict[str, Any]:
        """Build context dictionary for city-wide state"""
        # Calculate power utilization
        total_demand = self.city.get_total_power_demand()
        power_utilization = (total_demand / self.city.total_power) * 100 if self.city.total_power > 0 else 0
        
        # Count unsatisfied buildings
        unsatisfied = sum(
            1 for b in self.city.buildings
            if b.allocated_power < b.power_requirement * 0.8
        )
        
        # Count active emergencies
        active_emergencies = sum(1 for e in self.city.emergencies if not e.resolved)
        
        # Count blocked roads
        blocked_roads = len(self.city.blocked_roads)
        
        # Count affected vehicles
        affected_vehicles = sum(1 for v in vehicles if v.status == VehicleStatus.STUCK)
        
        return {
            "tick": tick,
            "weather": self.city.weather.value,
            "weather_modifier": self.city.get_weather_modifier(),
            "power_utilization": power_utilization,
            "unsatisfied_buildings": unsatisfied,
            "active_emergencies": active_emergencies,
            "blocked_roads": blocked_roads,
            "affected_vehicles": affected_vehicles,
            "total_vehicles": len(vehicles)
        }
    
    def get_recent_alerts(self, limit: int = 20) -> List[Alert]:
        """Get most recent alerts"""
        return self.alerts[-limit:]
    
    def get_rule_statistics(self) -> dict:
        """Get statistics about rule firing"""
        return {
            "total_rules": len(self.rules),
            "enabled_rules": sum(1 for r in self.rules if r.enabled),
            "total_alerts": len(self.alerts),
            "rule_fire_counts": self.rule_fire_counts.copy()
        }
    
    def generate_explanation(self, alert: Alert) -> str:
        """Generate detailed explanation for an alert"""
        return (
            f"Logic Rule '{alert.rule_name}' (ID: {alert.rule_id}) triggered at tick {alert.tick}. "
            f"Alert Level: {alert.alert_level.value.upper()}. "
            f"Reasoning: {alert.message} "
            f"This rule uses IF-THEN logic to detect patterns in city behavior and vehicle telemetry."
        )